{"ast":null,"code":"// song.service.spec.ts\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { SongService } from './song.service';\ndescribe('SongService', () => {\n  let service;\n  let httpTestingController;\n  const mockSongs = [{\n    id: 1,\n    title: 'Song 1',\n    artist: 'Artist 1',\n    album: 'Album 1',\n    genre: 'Rock',\n    releaseDate: '2023-01-15',\n    duration: 180\n  }, {\n    id: 2,\n    title: 'Song 2',\n    artist: 'Artist 2',\n    album: 'Album 2',\n    genre: 'Pop',\n    releaseDate: '2023-02-20',\n    duration: 240\n  }];\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [SongService]\n    });\n    service = TestBed.inject(SongService);\n    httpTestingController = TestBed.inject(HttpTestingController);\n  });\n  afterEach(() => {\n    httpTestingController.verify();\n  });\n  fit('should_create_service_song', () => {\n    expect(service).toBeTruthy();\n  });\n  fit('should_retrieve_songs_from_the_API_via_GET', () => {\n    service.getSongs().subscribe(songs => {\n      expect(songs).toEqual(mockSongs);\n    });\n    const req = httpTestingController.expectOne(service.backendUrl);\n    expect(req.request.method).toEqual('GET');\n    req.flush(mockSongs);\n  });\n  fit('should_add_a_song_via_POST', () => {\n    const newSong = {\n      title: 'New Song',\n      artist: 'New Artist',\n      album: 'New Album',\n      genre: 'Jazz',\n      releaseDate: '2023-03-10',\n      duration: 300\n    };\n    service.addSong(newSong).subscribe(song => {\n      expect(song).toEqual(newSong);\n    });\n    const req = httpTestingController.expectOne(service.backendUrl);\n    expect(req.request.method).toEqual('POST');\n    req.flush(newSong);\n  });\n  fit('should_edit_a_song_via_PUT', () => {\n    const editedSong = {\n      id: 1,\n      title: 'Edited Song',\n      artist: 'Artist 1',\n      album: 'Album 1',\n      genre: 'Rock',\n      releaseDate: '2023-01-15',\n      duration: 200\n    };\n    service.updateSong(editedSong.id, editedSong).subscribe(song => {\n      expect(song).toEqual(editedSong);\n    });\n    const req = httpTestingController.expectOne(`${service.backendUrl}/${editedSong.id}`);\n    expect(req.request.method).toEqual('PUT');\n    req.flush(editedSong);\n  });\n  fit('should_get_a_song_by_id_via_GET', () => {\n    const songId = 1;\n    service.getSongById(songId).subscribe(song => {\n      expect(song).toEqual(mockSongs[0]);\n    });\n    const req = httpTestingController.expectOne(`${service.backendUrl}/${songId}`);\n    expect(req.request.method).toEqual('GET');\n    req.flush(mockSongs[0]);\n  });\n});","map":{"version":3,"names":["TestBed","HttpClientTestingModule","HttpTestingController","SongService","describe","service","httpTestingController","mockSongs","id","title","artist","album","genre","releaseDate","duration","beforeEach","configureTestingModule","imports","providers","inject","afterEach","verify","fit","expect","toBeTruthy","getSongs","subscribe","songs","toEqual","req","expectOne","backendUrl","request","method","flush","newSong","addSong","song","editedSong","updateSong","songId","getSongById"],"sources":["/home/coder/project/workspace/angularapp/src/app/services/song.service.spec.ts"],"sourcesContent":["// song.service.spec.ts\n\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { SongService } from './song.service';\nimport { Song } from '../model/song.model';\n\ndescribe('SongService', () => {\n  let service: SongService;\n  let httpTestingController: HttpTestingController;\n\n  const mockSongs: Song[] = [\n    {\n      id: 1,\n      title: 'Song 1',\n      artist: 'Artist 1',\n      album: 'Album 1',\n      genre: 'Rock',\n      releaseDate: '2023-01-15',\n      duration: 180\n    },\n    {\n      id: 2,\n      title: 'Song 2',\n      artist: 'Artist 2',\n      album: 'Album 2',\n      genre: 'Pop',\n      releaseDate: '2023-02-20',\n      duration: 240\n    },\n  ];\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [SongService],\n    });\n    service = TestBed.inject(SongService);\n    httpTestingController = TestBed.inject(HttpTestingController);\n  });\n\n  afterEach(() => {\n    httpTestingController.verify();\n  });\n\n  fit('should_create_service_song', () => {\n    expect((service as any)).toBeTruthy();\n  });\n\n  fit('should_retrieve_songs_from_the_API_via_GET', () => {\n    (service as any).getSongs().subscribe((songs) => {\n      expect(songs).toEqual(mockSongs);\n    });\n    const req = httpTestingController.expectOne((service as any).backendUrl);\n    expect(req.request.method).toEqual('GET');\n    req.flush(mockSongs);\n  });\n\n  fit('should_add_a_song_via_POST', () => {\n    const newSong: Song = {\n      title: 'New Song',\n      artist: 'New Artist',\n      album: 'New Album',\n      genre: 'Jazz',\n      releaseDate: '2023-03-10',\n      duration: 300\n    };\n    (service as any).addSong(newSong).subscribe((song) => {\n      expect(song).toEqual(newSong);\n    });\n    const req = httpTestingController.expectOne((service as any).backendUrl);\n    expect(req.request.method).toEqual('POST');\n    req.flush(newSong);\n  });\n\n  fit('should_edit_a_song_via_PUT', () => {\n    const editedSong: Song = {\n      id: 1,\n      title: 'Edited Song',\n      artist: 'Artist 1',\n      album: 'Album 1',\n      genre: 'Rock',\n      releaseDate:'2023-01-15',\n      duration: 200\n    };\n    (service as any).updateSong(editedSong.id, editedSong).subscribe((song) => {\n      expect(song).toEqual(editedSong);\n    });\n    const req = httpTestingController.expectOne(`${(service as any).backendUrl}/${editedSong.id}`);\n    expect(req.request.method).toEqual('PUT');\n    req.flush(editedSong);\n  });\n\n  fit('should_get_a_song_by_id_via_GET', () => {\n    const songId = 1;\n    (service as any).getSongById(songId).subscribe((song) => {\n      expect(song).toEqual(mockSongs[0]);\n    });\n    const req = httpTestingController.expectOne(`${(service as any).backendUrl}/${songId}`);\n    expect(req.request.method).toEqual('GET');\n    req.flush(mockSongs[0]);\n  });\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}